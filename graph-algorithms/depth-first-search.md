## 深度优先搜索

深度优先搜索所使用的策略就像其名字所隐含的：只要可能，就在图中尽量深入。深度优先总是对最近才发现的结点 v 的出发边进行探索，直到该结点的所有出发边都被发现为止，一旦结点 v 的所有出发边都被发现，探索则回溯到 v 的前驱结点（v 是经过该结点才被发现的），来搜索该前驱结点的出发边。该过程一直持续到从源结点可以到达的所有结点都被发现为止。如果还存在尚未发现的结点，则深度优先搜索将从这些未被发现的结点中任选一个作为新的源结点，并重复同样的搜索过程。该算法重复整个过程，直到图中的所有结点都被发现为止。

像广度优先搜索一样，在对已被发现的结点 u 的邻接链表进行扫描时，每当发现一个结点 v 时，深度优先搜索算法将对这个事件进行记录，将 v 的前驱属性 v.pre 设置为 u。不过，与广度优先搜索不同的是，广度优先搜索的前驱子图形成一棵树，而深度优先搜索的前驱子图可能由多棵树组成，因为搜索可能从多个源结点重复进行。因此，我们给深度优先搜索的前驱子图所下的定义与广度优先搜索前驱子图所下的定义略有不同。设图 G<sub>pre</sub> = (V, E)，其中 E<sub>pre</sub> = {(v.pre, v) : v ∈ V 且 v.pre != null}。深度优先搜索的前驱子图形成一个由多棵深度优先树构成的深度优先森林，森林 E<sub>pre</sub> 中的边仍然称为树边。

像广度优先搜索算法一样，深度优先搜索算法在搜索过程中也是对结点进行涂色来指明结点的状态。每个结点的初始颜色都是白色，在结点被发现后变为灰色，在其邻接链表被扫描完成后变为黑色。该方法可以保证每个结点仅在一棵深度优先树中出现，因此，所有的深度优先树都是不相交的 (disjoint)。

除了创建一个深度优先搜索森林外，深度优先搜索算法还在每个结点盖上一个时间戳，每个结点 v 有两个时间戳：第一个时间戳 v.d 记录结点 v 第一次被发现的时间（涂上灰色的时候），第二个时间戳 u.f 记录的是搜索完成对 v 的邻接链表扫描的时间（涂上黑色的时候）。这些时间戳提供了图的重要信息，通常能够帮助推断深度优先搜索算法的行为。

下面的深度优先搜索的代码将其发现结点 u 的时刻记录在属性 u.d 中，将其完成对结点 u 处理的时刻记录在属性 u.f 中。因为 |V| 个结点中的每个结点只能有一个发现事件和一个完成事件，所以这些时间戳都是处于 1 和 2|V| 之间的整数。很显然，对每个结点 u，我们有：

u.d < u.f

结点 u 在时刻 u.d 之前为白色，在时刻 u.d 和 u.f 之间为灰色，在时刻 u.f 之后为黑色。

```java
class Vertex {
    // Other fields and methods ...

    boolean visited;
    Vertex pre;
    int d;
    int f;
}
```

下面的代码给出的是基本的深度优先搜索算法，输入图 G 既可以是无向图，也可以是有向图，变量 time 是一个全局变量，用来计算时间戳。

```java
int time;

void DFS(Graph graph) {
    int V = graph.V;
    for (int i = 0; i < V; i++) {
        Vertex u = graph.vertices[i];
        u.visited = false;
        u.pre = null;
    }
    time = 0;
    for (int i = 0; i < V; i++) {
        Vertex u = graph.vertices[i];
        if (!u.visited) {
            visit(graph, u);
        }
    }
}

void visit(Graph graph, Vertex u) {
    time++;
    u.d= time;
    u.visited = true;
    for (Edge e : graph.adj[u.id]) {
        Vertex v = graph.vertices[e.other(u.id)];
        if (!v.visited) {
            v.pre = u;
            visit(graph, v);
        }
    }
    time++;
    u.f = time;
}
```

注意，深度优先搜索的结果可能依赖于算法 DFS 中第二个 for 循环对结点进行检查的次序和算法 visit 的 for 循环对一个结点的邻接结点进行访问的次序。不过，这些不同的访问次序在实际中并不会导致问题，因为我们通常可以对任意的深度优先搜索结果加以有效利用，并获得等价的结果。

![](../assets/images/graph-algorithms/DFS1.png)

深度优先搜索算法 DFS 在有向图上的运行过程。随着算法对边的探索的推进，这些边或者变成有阴影的边（如果它们是树边），或者变为虚线边（其它情况）。非树边则根据其后（back）边、横向（cross）边或前后（forward）边而分别标记为 B、C 或 F。结点中的时间戳表明该结点的发现时间和完成时间。

DFS 的运行时间是多少呢？如果排除 visit 的时间，DFS 的两个 for 循环所需的时间为 Θ(V)。对每个结点 v ∈ V 来说，visit 被调用的次数刚好为一次，这是因为在对一个结点 u 调用 visit 时，该结点 u 必须是白色，而 visit 所做的第一件事情就是将结点 u 涂上灰色。在执行 visit 的过程中，for 循环的执行次数为 |adj[v]|。由于 ∑<sub>v∈V</sub>∣adj[v]∣ = Θ(E)，执行 visit for 循环的总成本是 Θ(E)。因此，深度优先搜索算法的运行时间为 Θ(V + E)。

### 深度优先搜索的性质































