## 计数排序

计数排序假设n个输入元素中的每一个都是在0到k区间内的一个整数，其中k为某个整数。当k = O(n)时，排序的运行时间是Θ(n)。

计数排序的基本思想是：对每一个输入元素x，确定小于x的元素个数，利用这一信息，就可以直接把x放到它在输出数组中的位置上了。例如，如果有17个元素小于x，则x就应该在第18个输出位置上。当有几个元素相同时，这一方案要略做修改，因为不能把它们放到同一个输出位置上。

在计数排序的代码中，假设输入是数组a[0...n - 1]，我们还需要两个数组：b[0...n - 1]存放排序的输出，c[0...k]提供临时存储空间。

```java
public int[] countingSort(int[] arr, int k) {
    int n = a.length;
    int[] b = new int[n];
    int[] c = new int[k + 1];
    for (int i = 0; i < k; i++) {
        c[i] = 0;
    }
    for (int i = 0; i < n; i++) {
        c[a[i]]++;
    }
    for (int i = 1; i <= k; i++) {
        c[i] += c[i - 1];
    }
    for (int i = 0; i < n; i++) {
        int x = a[i];
        b[c[x] - 1] = x;
        c[x]--;
    }
    return b;
}
```

计数排序的时间代价是多少呢？4个for循环所花时间分别为Θ(k)、Θ(n)、Θ(k)、Θ(n)。这样，总的时间代价就是Θ(k + n)。在实际工作中，当k = O(n)时，我们一般会采用计数排序，这时的运行时间为Θ(n)。

计数排序的下界优于Ω(n * lgn)，因为它并不是一个比较排序算法。事实上，它的代码中完全没有输入元素之间的比较操作。相反，计数排序是使用输入元素的实际值来确定其在数组中的位置。当我们脱离了比较排序模型的时候，Ω(n * lgn)这一下界就不再适用了。

计数排序的一个重要性质就是它是稳定的：具有相同值的元素在输出数组中的相对次序与它们在输入数组中的相对次序相同。也就是说，对两个相同的数来说，在输入数组中先出现的数，在输出数组中也位于前面。通常，这种稳定性只有当进行排序的数据还附带卫星数据时才比较重要。计数排序的稳定性很重要的另一个原因是：计数排序经常会别用作基数排序算法的一个子过程，为了使基数排序正确运行，计数排序必须是稳定的。

基于计数排序，我们能设计一个算法，它能够对任何给定的介于0到k之间的n个整数进行预处理，然后在O(1)的时间内回答输入的n个整数中有多少个落在区间[a...b]内。该预处理时间为Θ(n + k)。

```java
public int countingRange(int[] a, int k, int left, int right) {
    int n = a.length;
    int[] c = new int[k + 1];
    for (int i = 0; i < k; i++) {
        c[i] = 0;
    }
    for (int i = 0; i < n; i++) {
        c[a[i]]++;
    }
    for (int i = 1; i <= k; i++) {
        c[i] += c[i - 1];
    }
    if (left <= 0) {
        return c[right];
    } else {
        return c[right] - c[left - 1];
    }
}
```
