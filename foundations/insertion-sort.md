## 插入排序

### 直接插入排序

插入排序的工作方式就像许多人排序一手的扑克牌，开始时，我们的左手只有一张牌，它当然是排好序的。然后，我们每次从桌子上拿走一张牌并将它插入到左手中正确的
位置。为了找到一张牌的正确位置，我们从右到左将它与已在手中的每张牌进行比较。如下图所示，拿在左手中的牌总是排好序的。

![](../assets/images/part1/insertion-sort.png)

具体算法描述如下：

1. 从第一个元素开始，该元素可以认为已经被排序
2. 取出下一个元素，在已经排序的元素序列中从后向前扫描
3. 如果该元素（已排序）大于新元素，将该元素移到下一位置
4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置
5. 将新元素插入到该位置后
重复步骤2~5

![](../assets/images/part1/insertion-sort.gif)

用程序实现如下：

```java
public void insertionSort(int[] arr) {
    for (int j = 1; j < arr.length; j++) {
        int key = arr[j];
        int i = j - 1;
        while (i >= 0 && arr[i] > key) {
            arr[i + 1] = arr[i];
            i--;
        }
        arr[i + 1] = key;
    }
}
```

还可以把插入排序表示为如下的一个递归过程：为了排序数组的前n项，我们递归地排序前n-1项，然后把第n项插入已排序的前n-1个元素中。

```java
public void recursiveInsertionSort(int[] arr, int n) {
    if (n > 0) {
        recursiveInsertionSort(arr, n - 1);
        int key = arr[n];
        int i = n - 1;
        while (i >= 0 && arr[i] > key) {
            arr[i + 1] = arr[i];
            i--;
        }
        arr[i + 1] = key;
    }
}
```

时间复杂度：O(n^2)

空间复杂度：O(1)

边界情况：如果数组已经排好序，则出现最佳情况，时间复杂度为O(n)。如果数组已经反向排好序，则导致最坏情况，时间复杂度为O(n^2)。

应用：当数组元素比较少，或数组已经几乎完全有序时，需要移动的元素较少，插入排序是一个高效的排序算法。

### 二分插入排序

在插入排序中寻找一个元素合适的插入位置时，我们可以用二分查找法来减少比较的次数。在普通的插入排序中，我们第i次需要O(i)的时间才能找到一个元素合适的插入
位置，使用二分查找法，可以将查找时间减少为O(lgi)。但整个插入排序的时间复杂度仍然为O(n^2)，因为

### 希尔排序
