## 矩阵链乘法

给定一个n个矩阵的序列(矩阵链) <A1, A2, ..., An>，我们希望计算它们的乘积 A1A2...An。为了计算矩阵链乘积，我们可以先用括号明确计算次序，然后利用标准的矩阵相乘算法尽心计算。由于矩阵乘法满足结合律，因此任何加括号的方法都会得到相同的计算结果。我们称有如下性质的矩阵乘积链为完全括号化的(fully parenthesized)：它是单一矩阵，或者是两个完全括号化的矩阵链的积，且已外加括号。例如，如果矩阵链为<A1, A2, A3, A4>，则共有5种完全括号化的矩阵乘积链：
1. (A1(A2(A3A4)))
2. (A1((A2A3)A4))
3. ((A1A2){A3A4)
4. ((A1(A2A3))A4)
5. (((A1A2)A3)A4)

对矩阵链加括号的方式会对乘积运算的代价产生巨大影响，我们先来分析两个矩阵相乘的代价。下面是两个矩阵相乘的标准乘法。

```java
public int[][] matrixMultiply(int[][] a, int[][] b) {
    int aRows = a.length;
    int aColumns = a[0].length;
    int bRows = b.length;
    int bColumns = b[0].length;
    if (aColumns != bRows) {
        throw new IllegalArgumentException("incompatible dimensions");
    } else {
        int[][] c = new int[aRows][bColumns];
        for (int i = 0; i < aRows; i++) {
            for (int j = 0; j < bColumns; j++) {
                c[i][j] = 0;
                for (int k = 0; k < aColumns; k++) {
                    c[i][j] += a[i][k] + b[k][j];
                }
            }
        }
        return c;
    }
}
```

两个矩阵A和B只有相容(compatible)，即A的列数等于B的行数时，才能相乘。如果A是p x q的矩阵，B是q x r的矩阵，那么乘积C是p x r的矩阵。计算C所需时间由p * q * r决定。

我们以矩阵链<A1, A2, A3>相乘为例，来说明不同的加括号方案会导致不同的计算代价。假设三个矩阵的规模分别为10 x 100, 100 x 5和5 x 50。如果按((A1A2)A3)的顺序计算，为计算A1A2，需要做10 * 100 * 5 = 5000次标量乘法，再与A3相乘又需要做10 * 5 * 50 = 2500次乘法，共需7500次标量乘法。如果按(A1(A2A3))的顺序，计算A2A3需100 * 5 * 50 = 25000次乘法，A1再与之相乘又需10 * 100 * 50 = 50000次标量乘法，共需75000次标量乘法。因此，按第一种顺序计算矩阵链乘积要比第二种顺序快10倍。

矩阵链乘法问题(matrix-chain multiplication problem)可描述如下：给定n个矩阵的链<A1, A2, ..., An>，矩阵Ai的规模为p[i - 1] x p[i] (1 <= i <= n)，求完全括号化方案，使得计算乘积A1A2...An所需标量乘法次数最少。

注意，求解矩阵链乘法问题并不是要真正进行矩阵相乘运算，我们的目标只是确定代价最低的计算顺序。确定最优计算顺序所花费的时间通常要比随后真正进行矩阵相乘所节省的时间(例如仅进行7500次标量乘法而不是75000次)要少。

令P(n)表示可供选择的括号化方案的数量。当n = 1时，由于只有一个矩阵，因此只有一种完全括号化方案。当n >= 2时，完全括号化方案的矩阵乘积可描述为两个完全括号化的部分积相乘的形式，而两个部分积的划分点在第k个矩阵和第k + 1个矩阵之间，k为1, 2, ..., n - 1中的任意一个值。因此，我们可以得到如下递归公式：

![](./assets/images/part4/matrix-chain-multiplication.png)

括号化方案的数量与n呈指数关系，通过暴力搜索穷尽所有可能的括号化方案来寻找最优方案，是一个糟糕的策略。

### 应用动态规划方法

下面用动态规划方法来求解矩阵链的最优括号化方案，还是按照动态规划的4个步骤进行：

1. 刻画一个最优解的结构特征。

2. 递归地定义最优解的值。

3. 计算最优解的值，通常采用自底向上的方法。

4. 利用计算出的信息构造一个最优解。

我们按顺序进行这几个步骤，清楚地展示针对本问题每个步骤应该怎么做。

#### 步骤1：最优括号化方案的结构特征
动态规划方法的第一步是寻找最优子结构，然后就可以利用这种子结构从子问题的最优解构造出原问题的最优解。在矩阵链乘法问题中，此步骤的做法如下所述。为方便起见，我们用符号Ai..j(i <= j)表示AiAi+1...Aj乘积的结果矩阵。可以看出，如果问题是非平凡的，即i < j，那么为了对AiAi+1...Aj进行括号化，我们就必须在某个Ak和Ak+1之间将矩阵链划分开(k为i <= k < j之间的整数)。也就是说，对某个整数k，我们首先计算矩阵Ai..k和Ak+1..j，然后再计算它们的乘积得到最终结果呢Ai..j。此方案的计算代价等于矩阵Ai..k的计算代价，加上矩阵Ai+1..j的计算代价，再加上两者相乘的计算代价。

#### 步骤2：一个递归求解方案























