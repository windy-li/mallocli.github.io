## 贪心算法

求解最优化问题的算法通常需要经过一系列的步骤，在每个步骤都面临多种选择。对于许多最优化问题，使用动态规划算法来求最优解有些杀鸡用牛刀了，可以使用更简单、更高校的算法，贪心算法(greedy algorithm)就是这样的算法，它在每一步都做出当时看起来最佳的选择。也就是说，它总是做出局部最优的选择，寄希望这样的选择能导致全局最优解。

###活动选择问题

假定有一个n个活动(activity)的集合S = {a1, a2, ..., an}，这些活动使用同一个资源(例如一个阶梯教室)，而这个资源在某个时刻只能供一个活动使用。每个活动ai都有一个开始时间si和结束时间fi，其中0 <= si < fi < ∞。如果被选中，任务ai发生在半开区间[si, fi)起见。如果两个活动ai和aj满足[si, fi)和[sj, fj)不重叠，则称它们是兼容的。也就是说，若si >= fi或sj >= fj，则ai和aj是兼容的。在活动选择问题中，我们希望选出一个最大兼容活动集。假定活动已按结束时间的单调递增顺序排序：

f1 <= f2 <= f3 <= ... <= fn-1 <= fn

考虑下面的活动集合S:

![](./assets/images/part4/greedy-algorithm.png)

对于这个例子，子集{a3, a9, a11}由相互兼容的活动组成，但它不是一个最大集，因为子集{a1, a4, a8, a11}更大。实际上，{a1, a3, a8, a11}是一个最大兼容活动子集，另一个最大子集是{a2, a4, a9, a11}。

### 活动选择问题的最优子结构












