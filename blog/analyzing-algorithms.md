## 分析算法

分析算法的结果意味着预测算法需要的资源。虽然有时我们主要关心像内存、通信带宽或计算机硬件这类资源，但是通常我们想度量的是计算时间。一般来说，通过分析求解某个问题的几种候选算法，我们可以选出一种最有效的算法。这种分析可能指出不止一个可行的候选算法，但是在这个过程中，我们往往可以抛弃几个较差的算法。

在能够分析一个算法之前，我们必须有一个要使用的实现技术的模型，包括描述所用资源及其代价的模型。我们假定一种通用的单处理器计算模型-随机访问机(random-access machine, RAM)来作为我们的实现技术，算法可以用计算机程序来实现。在RAM模型中，指令一条接一条地执行，并没有并发操作。

严格地说，我们应该精确地定义RAM模型的指令及其代价。然而，这样做既乏味又对算法的设计与分析没有多大的意义。我们还要注意不能滥用RAM模型的指令及其代价。例如，如果一台RAM有一条排序指令，会怎样呢？这时，我们只用一条指令就能排序。这样的RAM是不现实的，因为真实的计算机并没有这样的指令。所以，我们的指导性意见是真实计算机如何设计，RAM就如何设计。RAM模型包含真实计算机中常见的指令：算数指令(如加法、减法、乘法、除法、取余、向下取整、向上取整)、数据移动指令(装入、存储、复制)和控制指令(条件与无条件转移、子程序调用与返回)。每条这样的指令所需时间都为常量。

RAM模型中的数据类型有整数型和浮点实数型。虽然我们一般不关心精度，但是在某些应用中，精度是至关重要的。我们还对每个数据字的规模假定一个范围。例如，当处理规模为n的输入时，我们一般假定对某个大于等于1的常量c，整数由c * lgn位来表示。我们要求c大于等于1，这样每个字都可以保存n的值，从而使得我们能索引单个输入元素。我们限制c为常量，这样字长就不会任意增长。(如果字长可以任意增长，我们就能在一个字中存储巨量的数据，并且其上的操作都在常量时间内进行，这种情况显然不现实。)

真实的计算机包含一些上面未列出的指令，这些指令代表了RAM模型中的一个灰色区域。例如，指数运算是一条常量时间的指令吗？一般情况下不是，当x和y都是实数时，计算x ^ y需要若干条指令。然而，在受限情况下，指数运算又是一个常量时间的操作。许多计算机都有“左移”指令，它在常量时间内将一个整数的各位向左移k位。在绝大多数计算机中，将一个整数的各位向左移一位等价于将该整数乘以2，结果将一个整数各位向左移k位等价于将该整数乘以2 ^ k。所以，只要k不大于一个计算机字的位数，这样的计算机就可以由一条常量时间的指令来计算2 ^ k，即将整数1向左移k位。我们尽量避免RAM模型中这样的灰色区域，但是，当k是一个足够小的正整数时，我们将2 ^ k的计算看成一个常量时间的操作。

一个算法在特定输入上的**运行时间**是指执行的基本操作数或步数。定义“步”的概念以便尽量独立于机器是方便的。目前，让我们采纳以下观点，执行每行代码需要常量时间。虽然一行与另一行可能需要不同数量的时间，但是我们假定第i行执行需要时间ci，其中ci是一个常量。这个观点与RAM模型是一致的，并且也反映了代码在大多数真实计算机上如何实现。
