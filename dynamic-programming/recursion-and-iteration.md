## 递归与迭代

递归和迭代是算法设计中常用的两种方法，它们往往可以相互转换。一般来说，迭代的效率要高于递归，但递归声明的结构并不总能够转换为迭代结构，有一些特定的问题，只能用递归来求解。

#### 递归的定义

递归在计算机科学中是指一种通过重复将问题分解为同类的子问题而解决问题的方法。通俗地说就是程序调用自身，函数自己调用自己，它通常把一个大型的复杂的问题转化为一个与原问题相似的规模较小的问题来解决。递归式方法可以被用于解决很多的计算机科学问题，因此它是计算机科学中十分重要的一个概念。计算机科学家尼克劳斯·维尔特如此描述递归：

> 递归的强大之处在于它允许用户用有限的语句描述无限的对象。因此，在计算机科学中，递归可以被用来描述无限步的运算，尽管描述运算的程序是有限的。

#### 递归的两个条件：

1. 可以通过递归调用来缩小问题规模，且新问题与原问题有着相同的形式。（自身调用）

2. 存在一种基本情况，可以使递归在简单情境下退出。（递归出口）

“依此类推”是递归的基本思想，具体来讲就是把规模大的问题转化为规模小的相似的子问题来解决。在函数实现时，因为解决大问题的方法和解决小问题的方法往往是同一个方法，所以就产生了函数调用它自身的情况。另外这个解决问题的函数必须有明显的结束条件，这样就不会产生无限递归的情况了。

#### 递归算法的一般形式

递归的基本思想是把规模大的问题转化为规模小的相似的子问题来解决。在函数实现时，因为解决大问题的方法和解决小问题的方法往往是同一个方法，所以就产生了函数调用它自身的情况。另外这个解决问题的函数必须有明显的结束条件，这样就不会产生无限递归的情况了。

需注意的是，规模大转化为规模小是核心思想，但递归并非是只做这步转化，而是把规模大的问题分解为规模小的子问题和可以在子问题解决的基础上剩余的可以自行解决的部分。而后者就是归的精髓所在，是在实际解决问题的过程。

可以把递归的思想用如下的形式表达出来：

```
func(大规模) {
    if (endCondition) {
        end; // 结束条件，递归的出口
    } else {
        func(小规模); // 递归
        solve; // 解决该步中剩余部分的问题
    }
}
```

利用递归可以解决很多问题：如计算阶乘，斐波那契数列，背包问题，汉诺塔问题等。以计算阶乘为例，计算阶乘的程序在数学上可以定义为：

![](../assets/images/part3/recursion-and-iteration1.png)

可以通过下面的递归算法来求解：

```java
int factorial(int n) {
    if (n == 0) {
        return 1;
    } else {
        return n * factorial(n - 1);
    }
}
```

递归是为了最能表达这种思想，所以用“递归”这个词，其实递归可以是“有去有回”，也可以是“有去无回”。但其根本是“由大往小地去，由近及远地去”。“递”是必需，“归”并非必需，依赖于要解决的问题，有的需要去的路上解决，有的需要回来的路上解决。有递无归的递归其实就是我们很容易理解的一种分治思想。

其实理解递归可能没有“归”，只有去（分治）的情况，我们应该想到递归也许可以既不需要在“去”的路上解决问题，也不需要在“归”的路上解决问题，只需在路的尽头解决问题，即在满足停止条件时解决问题。将这种递归情形用递归程序描述如下：

```
func(大规模) {
    if (endCondition) {
        solve;
    } else {
        for loop:
            func(小规模);
    }
}
```

例如，字符串的全排列就可以用这种递归简洁地表达出来：

```java
void permute(String prefix, String str) {
    if (str.length == 0) {
        System.out.print(prefix);
    } else {
        for (int i = 0; i < str.length; i++) {
            permute(prefix + str[i], str.substr(0, i) + str.substr(i + 1, str.length));
        }
    }
}
```

由这个例子，可以发现这种递归对递归函数参数出现了设计要求，即便递归到尽头，组合的字符串规模（长度）也没有变小，规模变小的是递归函数的一个参数。可见，这种变化似乎一下将递归的灵活性大大地扩展了，所谓的大规模转换为小规模需要有一个更为广义的理解了。

#### 迭代

迭代就是利用变量的原值推算出变量的一个新值，如果递归是 A 自己调用自己的话，迭代就是 A 反复地调用 B。由于没有频繁的函数调用的开销，所以迭代往往比递归效率更高。迭代的基本思想比递归简单，就是一步一步地自底向上计算，在动态规划中往往采用迭代的方法来计算。
