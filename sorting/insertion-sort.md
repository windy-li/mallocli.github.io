## 插入排序

### 直接插入排序

对于少量元素的排序，插入排序是一个高效的算法。插入排序的工作方式就像许多人排序一手的扑克牌，开始时，我们的左手只有一张牌，它当然是排好序的。然后，我们每次从桌子上拿走一张牌并将它插入到左手中正确的位置。为了找到一张牌的正确位置，我们从右到左将它与已在手中的每张牌进行比较。

具体算法描述如下：

1. 从第一个元素开始，该元素可以认为已经被排序
2. 取出下一个元素，在已经排序的元素序列中从后向前扫描
3. 如果扫描到的元素大于新元素，将该元素移到下一位置
4. 重复步骤 3 ，直到找到已排序的元素小于或者等于新元素的位置
5. 将新元素插入到该位置后
重复步骤 2 ~ 5

用程序实现如下：

```c
void InsertionSort(int *arr, int len) {
    for (int j = 1; j < len; j++) {
        int key = arr[j];
        int i = j - 1;
        while (i >= 0 && arr[i] > key) {
            arr[i + 1] = arr[i];
            i--;
        }
        arr[i + 1] = key;
    }
}
```

在插入排序中，若输入数组本身就是排好序的，则出现最佳情况，每个元素只比较一次，不需要任何的移动，这时算法运行的时间是 O(n)。若数组本身是反向排好序的，则导致最坏情况，我们必须将每个待插入的元素与整个已排序子数组的每个元素进行比较并移动，这时算法的运行时间是 O(n<sup>2</sup>)。

在分析插入排序时，我们既研究了最坏情况，又研究了最好情况，然而，在实际中，我们往往只考虑最坏情况运行时间，即对于规模为 n 的输入，算法的最长运行时间。下面给出这样做的三个理由：

1. 一个算法的最坏情况运行时间给出了任何输入的运行时间的一个上界，知道了这个界，我们就能确保该算法绝不需要更长时间。

2. 对某些算法，最坏情况经常出现。例如，当在数据库中检索一条信息时，若数据库中没有该信息，则检索算法的最坏情况就出现了。在某些应用中，对缺失信息的检索可能是频繁的。

3. 平均情况往往与最坏情况大致一样差。在插入排序中，将一个新元素 arr[j] 插入到已排序的子数组 arr[0...j-1]中，平均来说，arr[0...j-1] 中的元素一半小于 arr[j] 一半大于 arr[j]，导致的平均情况运行时间和最坏情况运行时间一样，也是 O(n<sup>2</sup>)。

在某些特定的情况下，我们会对一个算法的平均情况运行时间感兴趣，例如快速排序。使用随机化算法，做出一些随机的处理，以允许进行概率分析并产生某个期望运行时间。

### 递归插入排序

还可以把插入排序表示为如下的一个递归过程：为了排序数组的前 n 项，我们递归地排序前 n - 1 项，然后把第 n 项插入已排序的前 n - 1 个元素中。

```c
void RecursiveInsertionSort(int *arr, int j) {
    if (j >= 1) {
        RecursiveInsertionSort(arr, j - 1);
        int key = arr[j];
        int i = j - 1;
        while (i >= 0 && arr[i] > key) {
            arr[i + 1] = arr[i];
            i--;
        }
        arr[i + 1] = key;
    }
}
```

### 二分插入排序

在插入排序中寻找一个元素合适的插入位置时，我们可以用二分查找法来减少比较的次数。在普通的插入排序中，第 i 次需要 O(i) 的时间才能找到一个元素合适的插入位置，使用二分查找法，可以将查找时间减少为 O(lgi)。但二分插入排序只能减小运行时间的常数系数，不能减小渐近运行时间，整个插入排序的时间复杂度仍然为 O(n<sup>2</sup>)，因为第 i 次找到合适的位置，需要移动的元素个数没有改变，移动的时间复杂度仍然为 O(i)。

```c
int binarySearch(int *arr, int low, int high, int key) {
    while (low <= high) {
        int mid = (low + high) / 2;
        if (key == arr[mid]) {
            return arr[mid];
        } else if (key < arr[mid]) {
            high = mid - 1;
        } else {
            low = mid + 1;
        }
    }
    return -(low + 1);
}

void BinaryInsertionSort(int *arr, int len) {
    for (int j = 0; j < len; j++) {
        int key = arr[j];
        int i = j - 1;
        int location = abs(binarySearch(arr, 0, j, key) + 1);
        while (i >= location) {
            arr[i + 1] = arr[i];
            i--;
        }
        arr[i + 1] = key;
    }
}
```

### 希尔排序

希尔排序是插入排序的一个变种，它的渐近运行时间和插入排序相同，但在大多数情况下，它比普通插入排序稍快。希尔排序通过将全部元素分为几个区域，这样可以让一个元素可以一次性朝最终位置前进一大步，然后算法再取越来越小的步长进行排序，最后一步就是普通的插入排序，但是到了这一步，整个数组几乎是已排好的了（此时插入排序较快）。

假设有一个很小的数据在一个已按升序排好序的数组的末端，使用直接插入排序，需要进行 n - 1 次的比较和交换才能将该数据移到正确位置。而希尔排序会用较大的步长移动数据，所以小数据只用进行少数比较和交换即可放到正确位置。

一个更好理解的希尔排序实现：将数组列在一个表中并对列排序（用插入排序），重复这过程，不过每次用更长的列来进行。最后整个表就只有一列了。将数组转换为表是为了更好地理解这个算法，算法本身仅仅对原数组进行排序（通过增加索引的步长，例如是用 i += stepSize 而不是 i++）。

例如，假设有这样一组数 [13, 14, 94, 33, 82, 25, 59, 94, 65, 23, 45, 27, 73, 25, 39, 10]，如果我们以步长为 5 开始进行排序，我们可以通过将这个数组放在有 5 列的表中来更好地描述算法，这样它们看起来就应该是这样：

```
13 14 94 33 82
25 59 94 65 23
45 27 73 25 39
10
```

然后我们对每列进行排序：

```
10 14 73 25 23
13 27 94 33 39
25 59 94 65 82
45
```

将上述四行数字，依序接在一起时我们得到：[10, 14, 73, 25, 23, 13, 27, 94, 33, 39, 25, 59, 94, 65, 82, 45]。这时 10 已经移到正确位置了，然后再以 3 为步长进行排序：

```
10 14 73
25 23 13
27 94 33
39 25 59
94 65 82
45
```

排序之后变为：

```
10 14 13
25 23 33
27 25 59
39 65 73
45 94 82
94
```

最后以 1 为步长进行排序，此时就是简单的插入排序了。

```c
void ShellSort(int *arr, int len) {
    for (int gap = len / 2; gap > 0; gap /= 2) {
        for (int j = gap; j < len; j++) {
            int key = arr[j];
            int i = j - gap;
            while (i >= 0 && arr[i] > key) {
                arr[i + gap] = arr[i];
                i -= gap;
            }
            arr[i + gap] = key;
        }
    }
}
```

步长的选择是希尔排序的重要部分，只要最终步长为 1，任何步长序列都可以工作。算法最开始以较大的步长进行排序，然后以较小的步长进行排序，最终以步长为 1 进行排序。当步长为 1 时，算法变为普通插入排序，这就保证了数据一定会被排序。
