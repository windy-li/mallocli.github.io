## 赫夫曼编码

赫夫曼编码可以很有效地压缩数据：通常可以节省20%~90%的空间，具体压缩率依赖于数据的特性。我们将待压缩数据看做字符序列，根据每个字符的出现频率，赫夫曼贪心算法构造出字符的最优二进制表示。

假定我们压缩一个10万个字符的数据文件，下表给出了文件所出现的字符和它们的出现频率。也就是说，文件中只出现了6个不同的字符，其中字符a出现了45000次。

|           | a     | b | c | d | e | f |
|:----------|:------|:------|:------|:------|:------|:------|
| 频率(千次)  |  45  | 13  |12  |16  |9  |5  |
| 定长编码    | 000  | 001  |010  |011  |100  |101  |
| 变长编码    |   0  | 101   |100  |111  |1101  |1100  |

一个100 000个字符的文件，只包含a~f 6个不同字符，出现频率如上表所示。如果为每个字符制定一个3位的码字，我们可以将文件编码为300 000位的长度。但使用上表所示的变长编码，我们可以仅用224 000位编码文件。

我们有很多方法可以表示这个文件的信息。考虑一种二进制字符编码(或简称编码)的方法，每个字符用一个唯一的二进制字符串表示，称为码字。如果使用定长编码，需要用3位来表示6个字符：a = 100, b = 001, ..., f = 101。这种方法需要300 000个二进制位来编码文件。是否有更好的编码方案呢？

变长编码(variable-length code)可以达到比定长编码好得多的压缩率。其思想是赋予高频字符短码字，赋予低频字符长码字。上表显示了本例的一种变长编码：1位的串0表示a，4位的串1100表示f。因此，这种编码表示此文件共需(45 * 1 + 13 * 3 + 12 * 3 + 16 * 3 + 9 * 4 + 5 * 4) * 1000 = 224 000位，与定长编码相比节约了25%的空间。实际上，我们将看到，这是此文件的最优字符编码。

#### 前缀码

我们这里只考虑所谓的前缀码(prefix code)，即没有任何码字是其它码字的前缀。任何二进制字符码的编码过程都很简单，只要将表示每个字符的码字连接起来即可完成文件压缩。例如，使用上表所示的变长前缀码，我们可以将3个字符的文件abc编码为0.101.100，其中.表示连结操作。

前缀码的作用是简化解码过程。由于没有码字是其它码字的前缀，编码文件的开始码字是无歧义的，我们可以简单地识别出开始码字，将其转换回原字符，然后对编码文件剩余部分重复这种解码过程。在这个例子中，二进制串001011101可以唯一地解析为0.0.101.1101，解码为aabe。

解码过程需要前缀码的一种方便的表示形式，以便我们可以容易地截取开始码字。一种二叉树可以满足这种需求，其叶结点为给定的字符。字符的二进制码字用从根节点到该字符叶结点的简单路径表示，其中0意味着“转向左孩子”，1意味着“转向右孩子”。下图给出了两个编码示例的二叉树表示。注意，编码树并不是二叉搜索树，因为叶结点并未有序排列，而内部结点并不包含字符关键字。

![](./assets/images/part4/Huffman-code.png)

文件的最优编码方案总是对应一棵满(full)二叉树，即每个非叶结点都有两个孩子结点。前文给出的定长编码实例不是最优的，因为它的二叉树表示并非满二叉树，如上图a所示，它包含以10开头的码字，但不包含以11开头的码字。现在我们可以只关注满二叉树了，因此可以说，若C为字母表且所有字符的出现频率均为正数，则最优前缀码对应的数恰有C个叶节点，每个叶节点对应字母表中一个字符，且恰有C - 1个内部结点。

给定一棵对应前缀码的树T，我们可以容易地计算出编码一个文件需要多少个二进制位。对于字母表C中的每个字符c，令属性c.freq表示c在文件中出现的频率，令depth(c)表示c的叶节点在树中的深度。注意，depth(c)也是字符串c的码字的长度，则编码文件需要

![](./assets/images/part4/Huffman-code2.png)

个二进制位，我们将B(T)定义为T的代价。

#### 构造赫夫曼编码

赫夫曼设计了一个贪心算法来构造最优前缀码，被称为**赫夫曼编码(Huffman code)**。它的正确性证明也依赖于贪心选择性质和最优子结构。

在下面的代码中，我们自底向上地构造出对应最优编码的二叉树T，它从C个叶节点开始，执行C - 1个合并操作创建出最终的二叉树，当合并两个对象时，得到的新对象的频率设置为原来两个对象的频率之和。

```java
public class Huffman {
    private static class Node implements Comparable<Node> {
        char key;
        int weight;
        Node left;
        Node right;

        Node() {
            this.key = '-';
        }

        Node(char key, int weight) {
            this.key = key;
            this.weight = weight;
        }

        @Override
        public int compareTo(Node that) {
            return Integer.compare(this.weight, that.weight);
        }
    }

    public static Node buildTree(char[] keys, int[] weights) {
        int n = keys.length;
        Node[] nodes = new Node[n];
        for (int i = 0; i < n; i++) {
            nodes[i] = new Node(keys[i], weights[i]);
        }
        PriorityQueue<Node> queue = new PriorityQueue<>();
        for (Node node : nodes) {
            queue.offer(node);
        }
        for (int i = 0; i < n - 1; i++) {
            Node z = new Node();
            Node x = queue.poll();
            Node y = queue.poll();
            z.left = x;
            z.right = y;
            z.weight = x.weight + y.weight;
            queue.offer(z);
        }
        return queue.poll();
    }

    public static void printCode(Node node, String s) {
        if (node != null) {
            printCode(node.left, s + "0");
            if (node.left == null && node.right == null) {
                System.out.println(node.key + ": " + s);
            }
            printCode(node.right, s + "1");
        }
    }
}
```

对于前文给出的例子，赫夫曼算法的执行过程如下图所示。由于字母表包含6个字母，初始队列大小为n = 6，需要5个合并步骤构造二叉树，最终的二叉树表示最优前缀码。一个字母的码字为根节点到该字母叶节点的简单路径上标签的序列。

![](./assets/images/part4/Huffman-code3.png)

上图给出了赫夫曼算法的执行过程。每一部分显示了优先队列的内容，已按频率递增顺序排好序。在每个步骤，频率最低的两棵树进行合并。叶节点用矩形表示，没个叶节点包含一个字符及其频率。内部结点用圆圈表示，包含其孩子结点的频率之和。内部结点指向左孩子的边标记为0，指向右孩子的边标记为1，一个字母的码字对应从根到其叶节点的路径上的边的标签序列。(a)初始集合有n = 6个结点，每个节点对应一个字母，(b) ~ (e)为中间步骤，(f)为最终的编码树。

for循环反复从队列中提取两个频率最低的结点x和y，将它们合并为一个新结点z，替代它们。z的频率为x和y的频率之和、结点z将x作为其左孩子，将y作为其右孩子(顺序是任意的，交换左右孩子会生成一个不同的编码，但代价完全一样)。经过n - 1次合并后，第9行返回队列中剩下的唯一结点——编码树的根节点。

为了分析赫夫曼算法的运行时间，我们假定最小优先队列Q是使用最小二叉堆实现的。对一个n个字符的集合C，我们用buildMinHeap过程将Q初始化，花费时间为O(n)。for循环执行了n - 1次，且每个堆操作需要O(lgn)的时间，所以循环对总时间的贡献为O(n * lgn)。因此，处理一个n个字符的集合，Huffman算法的总运行时间为O(n * lgn)。
