## 简述

这一部分介绍了几种解决如下排序问题的算法：

输入：一个 n 个数的序列 <a1, a2, ..., an>。输出：输入序列的一个排列（重排） <a'1, a'2, ..., a'n>，使得 a'1 <= a'2 <= ... <= a'n。输入序列通常是一个 n 元数组，尽管它可能用链表等其它方式描述。

#### 数据的结构

实际上，待排序的数很少是单独的数值，而是数据集某条记录（record）的一部分，我们要排序的是这个数据集中所有的记录。每个记录包含一个关键字（key），就是排序问题中要重排的值。记录中的剩余部分由卫星数据（satellite data）组成，通常与关键字是一同存取的。在实际中，当一个排序算法重排关键字时，也必须要重排卫星数据。如果每个记录包含大量卫星数据，我们通常重排记录指针的数组，而不是记录本身，这样可以减少数据移动量。

在某种意义上，正是这些实现的细节将一个算法与成熟的程序区分开来。一个排序算法描述确定有序次序的方法（method），而不管我们是在排序单独的数还是包含很多卫星数据的记录。因此，当关注排序问题时，我们通常假定输入只是由数字组成。将一个对数字进行排序的算法转换为一个对记录进行排序的程序，在概念上是很直接的，当然在具体的工程情境下，其它一些细节问题可能会使实际的编程工作遇到很多挑战。

#### 为什么要排序？

很多计算机科学家认为排序是算法研究中最基础的问题，其原因有很多：

* 有时应用本身就需要对信息进行排序。例如，为了准备用户财务报表，银行需要按编号对支票进行排序。

* 很多算法通常把排序作为关键子程序。例如，在一个渲染图形对象的程序中，图形对象是分层叠在一起的，这个程序可能就需要按层次关系来排序对象，以便能够按自底向上的顺序绘制对象。我们将看到大量的算法将排序作为子程序来使用。

* 现有的排序算法数量非常庞大，其中所使用的技术也非常丰富。实际上，很多重要的算法设计技术都体现在多年来研究者所设计的排序算法中，从这个角度看，排序问题还有很好的历史价值。

* 我们可以证明排序问题的一个非平凡下界。而我们的最佳上界能够与这个非平凡下界渐近相等，这就意味着我们介绍的算法是渐近最优的。而且，我们可以利用排序问题的下界来证明其它问题的下界。

* 在实现排序算法时会出现很多工程问题。某个特定环境下的最快的排序算法可能依赖很多因素，例如，关于关键字和卫星数据的前提条件、计算机主机的内存层次（缓存和虚拟内存）、软件环境。很多这类问题最好在算法层面来处理，而不是通过代码调优来解决。

#### 排序算法













































