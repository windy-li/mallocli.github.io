## 计数排序

计数排序假设 n 个输入元素的每一个都是 0 到 k 区间内的一个整数，其中 k 为某个整数。当 k = O(n) 时，排序的运行时间是 Θ(n)。

计数排序的基本思想是：对每一个输入元素 x，确定小于 x 的元素个数，利用这一信息，就可以直接把 x 放到它在输出数组中的位置上。例如，如果有 17 个元素小于 x，则 x 就应该在第 18 个输出位置上。当有几个元素相同时，这一方案要略做修改，因为不能把它们放到同一个输出位置上。

在计数排序算法的代码中，假设输入是数组 a[0...n-1]，我们还需要两个数组：b[0...n-1] 存放排序的输出，c[0...k] 提供临时存储空间。

```java
int[] countingSort(int[] a, int k) {
    int n = a.length;
    int[] b = new int[n];
    int[] c = new int[k + 1];
    for (int i = 0; i <= k; i++) {
        c[i] = 0;
    }
    for (int i = 0; i < n; i++) {
        c[a[i]]++;
    }
    for (int i = 1; i <= k; i++) {
        c[i] += c[i - 1];
    }
    for (int i = n - 1; i >= 0; i--) {
        int x = a[i];
        b[c[x] - 1] = x;
        c[x]--;
    }
    return b;
}
```

下图显示了计数排序的运行过程。在第一个 for 循环的初始化操作之后，数组 c 的值全部被置为 0。第二个 for 循环遍历每一个输入元素，如果如果一个输入元素的值为 i，就将 c[i] 值加 1，于是，c[i] 中保存的就是等于 i 的元素的个数，其中 i = 0, 1, ..., k。第三个 for 循环通过加总计算确定对每一个 i = 0, 1, ..., k，有多少输入元素是小于或等于 i 的。最后一个 for 循环，把每个元素 a[i] 放到它在输出数组 b 中的正确位置上。如果所有 n 个元素都是互异的，那么当第一次执行最后一个 for 循环时，对每一个 a[i] 值来说， c[a[i]] 就是 a[i] 在输出数组中的最终正确位置，这是因为共有 c[a[i]] 个元素小于或等于 a[i]。因为所有的元素都可能并不都是互异的，所以，我们每将一个值 a[i] 放入数组 b 中后，都要将 c[a[i]] 的值减 1。这样，当遇到下一个值等于 a[i] 的输入元素（如果存在）时，该元素可以直接被放到输出数组中 a[i] 的前一个位置上。

![](../assets/images/sorting-and-order-statistics/counting-sort.png)

计数排序在输入数组 a[0...7] 上的处理过程，其中 a 中的每一个元素都是不大于 k = 5 的非负整数。（a）第一个 for 循环执行后的数组 a 和辅助数组 c 的情况。（b）第二个 for 循环执行后，数组 c 的情况。（c）~（e）分别显示了第三个 for 循环的循环体迭代了一次、两次和三次之后，输出数组 b 和辅助数组 c 的情况，其中，数组 b 中只有浅色阴影部分有元素值填充。（f）最终排好序的输出数组 b。

计数排序的时间代价是多少呢？ 4 个 for 循环所花时间分别为 Θ(k)、Θ(n)、Θ(k)、Θ(n)。这样，总的时间代价就是 Θ(k + n)。在实际工作中，当 k = O(n) 时，我们一般会采用计数排序，这时的运行时间为 Θ(n)。

计数排序的下界优于 Ω(n * lgn)，因为它并不是一个比较排序算法。事实上，它的代码中完全没有输入元素之间的比较操作。相反，计数排序是使用输入元素的实际值来确定其在数组中的位置。当我们脱离了比较排序模型的时候，Ω(n * lgn) 这一下界就不再适用了。

计数排序的一个重要性质就是它是稳定的：具有相同值的元素在输出数组中的相对次序与它们在输入数组中的相对次序相同。也就是说，对两个相同的数来说，在输入数组中先出现的数，在输出数组中也位于前面。通常，这种稳定性只有当进行排序的数据还附带卫星数据时才比较重要。计数排序的稳定性很重要的另一个原因是：计数排序经常会被用作基数排序算法的一个子过程，为了使基数排序正确运行，计数排序必须是稳定的。

基于计数排序，我们能设计一个算法，它能够对任何给定的介于 0 到 k 之间的 n 个整数进行预处理，然后在 O(1) 的时间内回答输入的 n 个整数中有多少个落在区间 [left...right] 内。该预处理时间为 Θ(n + k)。

```java
int countingRange(int[] a, int k, int left, int right) {
    int n = a.length;
    int[] c = new int[k + 1];
    for (int i = 0; i <= k; i++) {
        c[i] = 0;
    }
    for (int i = 0; i < n; i++) {
        c[a[i]]++;
    }
    for (int i = 1; i <= k; i++) {
        c[i] += c[i - 1];
    }
    if (left <= 0) {
        return c[right];
    } else {
        return c[right] - c[left - 1];
    }
}
```
