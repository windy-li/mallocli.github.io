## 基数排序

基数排序是一种用在卡片排序机上的算法，一张卡片有 80 列，在每一列上机器可以选择在 12 个位置中的任一处穿孔。通过机械操作，我们可以对排序机“编程”来检查每个卡片中的给定列，然后根据穿孔的位置将它们分别放入 12 个容器中。操作员就可以逐个容器地收集卡片，其中第一个位置穿孔的卡片放在最上面，其次是第二个位置穿孔的卡片，以此类推。

对十进制数字来说，每列只会用到 10 个位置（另两个位置用于编码非数值字符），一个 d 位数将占用 d 列，一次只能查看一列。

从直观上来看，你可能会觉得应该按最高有效位进行排序，然后对得到的每个容器递归地进行排序，最后再把所有的结果合并起来。遗憾的是，为了排序一个容器中的卡片，10 个容器中的 9 个都必须先放在一边，这一过程产生了许多要保存的临时卡片。

与人们直观感受相悖的是，基数排序是先按最低有效位进行排序来解决卡片排序问题的。然后算法将所有卡片合并成一叠，其中 0 号容器中的卡片都在 1 号容器中的卡片之前，而 1 号容器中的卡片又在 2 号容器中的卡片前面，以此类推。之后，用同样的方法按次低有效位对所有的卡片进行排序，并把排好序的卡片再次合并成一叠。重复这一过程，直到对所有的 d 位数字都进行了排序。此时，所有卡片已按 d 位数字完全排好序，所以，对这一叠卡片的排序仅需进行 d 轮。

![](../assets/images/sorting-and-order-statistics/radix-sort.png)

上图是一个由 7 个 3 位数组成的列表的基数排序过程。最左边的一列是输入数据，其余各列显示了由低位到高位连续进行排序后列表的情况，阴影指出了进行排序的位。

为了确保基数排序的正确性，一位数排序算法必须是稳定的。卡片排序机所执行的排序是稳定的，但操作员必须确保卡片从容器中被取出时不改变顺序，即使一个容器中所有的卡片在该位都是相同的数字也要确保这一点。

在一台典型的串行随机存取计算机上，我们有时会用基数排序来对具有多关键字域的记录进行排序。例如，我们希望用三个关键字（年、月、日）来对日期进行排序。对这个问题，我们可以使用基于特殊比较函数的排序算法，给定两个日期，先比较年，如果相同，再比较月，如果还是相同，就比较日。我们也可以采用另一种方法，用一种稳定排序算法对这些信息进行三次排序：先日，再月，最后是年。

下面是基数排序的代码实现，输入数组存放了 n 个 d 位元素，其中第 1 位是最低位，第 d 位是最高位。

```java
void radixSort(int[] arr) {
    int d = maxBit(arr);
    int n = arr.length;
    int[] temp = new int[n];
    int[] count = new int[10];
    int radix = 1;
    for (int i = 1; i <= d; i++) { // 进行d次排序
        for (int j = 0; j < 10; j++) {
            count[j] = 0; // 每次分配前清空计数器
        }
        for (int j = 0; j < n; j++) {
            int k = (arr[j] / radix) % 10; // 统计每个桶中的记录数
            count[k]++;
        }
        for (int j = 1; j < 10; j++) {
            count[j] += count[j - 1]; // 将temp中的位置依次分配给每个桶
        }
        for (int j = n - 1; j >= 0; j--) { // 将所有桶中记录依次收集到temp中
            int k = (arr[j] / radix) % 10;
            temp[count[k] - 1] = arr[j];
            count[k]--;
        }
        for (int j = 0; j < n; j++) { // 将临时数组的内容复制到arr中
            arr[j] = temp[j];
        }
        Util.printArray(arr);
        radix *= 10;
    }
}

int maxBit(int[] arr) {
    int maxData = arr[0];
    for (int i = 1; i < arr.length; i++) {
        maxData = Math.max(maxData, arr[i]);
    }
    int d = 1;
    while (maxData >= 10) {
        maxData /= 10;
        d++;
    }
    return d;
}
```

> 引理：给定 n 个 d 位数，其中每一个数位有 k 个可能的取值，如果 radixSort 使用的稳定排序算法耗时 Θ(n + k)，那么它就可以在 Θ(d(n + k)) 时间内将这些数排好序。

证明：基数排序的正确性可以通过对被排序的列进行归纳而加以证明。对算法时间代价的分析依赖于所使用的稳定的排序算法。当每位数字都在 0 到 k - 1 区间内（这样它就有 k 个可能的取值），且 k 的值不太大的时候，计数排序是一个好的选择。对 n 个 d 位数每一轮耗时 Θ(n + k)，共有 d 轮，因此基数排序的总时间为Θ(d(n + k))。

当 d 为常数且 k = O(n) 时，基数排序具有线性的时间代价。在更一般的情况中，我们可以灵活地决定如何将每个关键字分解成若干位。

基数排序是否比基于比较的排序算法（如快速排序）更好呢？通常情况下，基数排序的运行时间为 Θ(n)，这一结果看上去要比快速排序的期望运行时间代价 Θ(n * lgn) 更好一些，但是，在这两个表达式中，隐含在 Θ 符号背后的常数项因子是不同的，在处理 n 个关键字时，尽管基数排序执行的循环轮数比快速排序要少，但每一轮它所消耗的时间要长得多。哪一个排序算法更合适依赖于具体实现和底层硬件的特性（例如，快速排序通常可以比基数排序更有效地利用硬件的缓存），以及输入数据的特征。此外，利用计数排序作为中间稳定排序的基数排序不是原址排序，而很多 Θ(n * lgn) 时间的比较排序是原址排序。因此，当主存的容量比较宝贵时，我们可能更会倾向于像快速排序这样的原址排序算法。
