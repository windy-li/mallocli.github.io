## 插入排序

### 直接插入排序

插入排序的工作方式就像许多人排序一手的扑克牌，开始时，我们的左手只有一张牌，它当然是排好序的。然后，我们每次从桌子上拿走一张牌并将它插入到左手中正确的
位置。为了找到一张牌的正确位置，我们从右到左将它与已在手中的每张牌进行比较。如下图所示，拿在左手中的牌总是排好序的。

![](../assets/images/part1/insertion-sort.png)

具体算法描述如下：

1. 从第一个元素开始，该元素可以认为已经被排序
2. 取出下一个元素，在已经排序的元素序列中从后向前扫描
3. 如果该元素（已排序）大于新元素，将该元素移到下一位置
4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置
5. 将新元素插入到该位置后
重复步骤2~5

![](../assets/images/part1/insertion-sort.gif)

用程序实现如下：

```java
public void insertionSort(int[] arr) {
    for (int j = 1; j < arr.length; j++) {
        int key = arr[j];
        int i = j - 1;
        while (i >= 0 && arr[i] > key) {
            arr[i + 1] = arr[i];
            i--;
        }
        arr[i + 1] = key;
    }
}
```

还可以把插入排序表示为如下的一个递归过程：为了排序数组的前n项，我们递归地排序前n-1项，然后把第n项插入已排序的前n-1个元素中。

```java
public void recursiveInsertionSort(int[] arr, int n) {
    if (n > 0) {
        recursiveInsertionSort(arr, n - 1);
        int key = arr[n];
        int i = n - 1;
        while (i >= 0 && arr[i] > key) {
            arr[i + 1] = arr[i];
            i--;
        }
        arr[i + 1] = key;
    }
}
```

时间复杂度：O(n^2)

空间复杂度：O(1)

边界情况：如果数组已经排好序，则出现最佳情况，时间复杂度为O(n)。如果数组已经反向排好序，则导致最坏情况，时间复杂度为O(n^2)。

应用：当数组元素比较少，或数组已经几乎完全有序时，需要移动的元素较少，插入排序是一个高效的排序算法。

### 二分插入排序

在插入排序中寻找一个元素合适的插入位置时，我们可以用二分查找法来减少比较的次数。在普通的插入排序中，我们第i次需要O(i)的时间才能找到一个元素合适的插入
位置，使用二分查找法，可以将查找时间减少为O(lgi)。但整个插入排序的时间复杂度仍然为O(n^2)，因为第i次找到合适的位置，需要移动的元素个数没有改变，移动
的时间复杂度仍然为O(i)。

```java
public void binaryInsertionSort(int[] arr) {
    for (int j = 1; j < arr.length; j++) {
        int key = arr[j];
        int location = Math.abs(binarySearch(arr, 0, j, key) + 1);
        int i = j - 1;
        while (i >= location) {
            arr[i + 1] = arr[i];
            i--;
        }
        arr[i + 1] = key;
    }
}

private int binarySearch(int[] arr, int fromIndex, int endIndex, int key) {
    int low = fromIndex;
    int high = endIndex;
    while (low <= high) {
        int mid = (low + high) / 2;
        if (key == arr[mid]) {
            return mid;
        } else if (key < arr[mid]) {
            high = mid - 1;
        } else {
            low = mid + 1;
        }
    }
    return -(low + 1);
}
```

### 希尔排序

希尔排序是插入排序的一个变种。希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素可以一次性地朝最终位置前进一大步。然后算
法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但是到了这步，需排序的数据几乎是已排好的了（此时插入排序较快）。

假设有一个很小的数据在一个已按升序排好序的数组的末端。使用直接插入排序，需要进行n-1次的比较和交换才能将该数据移至正确位置。而希尔排序会用较大的步长移
动数据，所以小数据只需进行少数比较和交换即可到正确位置。

一个更好理解的希尔排序实现：将数组列在一个表中并对列排序（用插入排序）。重复这过程，不过每次用更长的列来进行。最后整个表就只有一列了。将数组转换至表是
为了更好地理解这算法，算法本身仅仅对原数组进行排序（通过增加索引的步长，例如是用i += stepSize而不是i++）。

例如，假设有这样一组数[13, 14, 94, 33, 82, 25, 59, 94, 65, 23, 45, 27, 73, 25, 39, 10]，如果我们以步长为5开始进行排序，我们可以通过将
这列表放在有5列的表中来更好地描述算法，这样他们就应该看起来是这样：

```
13 14 94 33 82
25 59 94 65 23
45 27 73 25 39
10
```

然后我们对每列进行排序：

```
10 14 73 25 23
13 27 94 33 39
25 59 94 65 82
45
```

将上述四行数字，依序接在一起时我们得到：[10, 14, 73, 25, 23, 13, 27, 94, 33, 39, 25, 59, 94, 65, 82, 45]。这时10已经移至正确位置了，然
后再以3为步长进行排序：

```
10 14 73
25 23 13
27 94 33
39 25 59
94 65 82
45
```

排序之后变为：

```
10 14 13
25 23 33
27 25 59
39 65 73
45 94 82
94
```

最后以1步长进行排序，此时就是简单的插入排序了。

```java
public void shellSort(int[] arr) {
    int n = arr.length;
    for (int gap = n / 2; gap > 0; gap /= 2) {
        for (int j = gap; j < n; j++) {
            int key = arr[j];
            int i = j - gap;
            while (i >= 0 && arr[i] > key) {
                arr[i + gap] = arr[i];
                i -= gap;
            }
            arr[i + gap] = key;
        }
    }
}
```

步长的选择是希尔排序的重要部分。只要最终步长为1任何步长序列都可以工作。算法最开始以一定的步长进行排序。然后会继续以一定步长进行排序，最终算法以步长为
1进行排序。当步长为1时，算法变为普通插入排序，这就保证了数据一定会被排序。

时间复杂度：希尔排序的时间复杂度仍然是O(n^2)。
